# ES6(ECMAScript 6) 문법
## ECMAScript
정보와 통신 시스템에 대한 표준을 제정하는 국제적 표준화 기구인 ECMA에서 만든 Javascript 표준.

거의 매년 새로운 버전의 표준이 제정되고 있으며, 현재 2023년에 제정된 ES14까지 나와있다.

React는 ES6의 javascript 문법부터 적용되기 때문에, ES6 문법을 먼저 알아야 한다.

ES6는 2015년에 만들어진 Javascript 표준으로 주로 사용하는 문법은 다음과 같다.
- const와 let
- Arrow function
- Template Literals
- Import와 export
- Destructing
- Default parameters
- Rest Operator
- Spread Operator

## const와 let
``const``는 상수를 만들기 위한 키워드이다. ``const``는 선언 시 반드시 초기화를 해야하며, 값을 재할당 할 수 없다.

``let``는 변수를 선언하기 위한 키워드이다. ``let``는 호이스팅(hoisting)할 수 없으며, 반드시 선언이 먼저 이루어져야 한다.

``let``와 ``var``은 사용하는 범위에 차이가 있다. ``var``은 범위가 달라도 같은 변수로서 처리되지만, ``let``은 범위가 다를 경우 따로따로 취급된다.
```javascript
var a = 10;
if(true){
  console.log(a); //10 출력
  var a = 20;
  console.log(a); //20 출력
}
console.log(a); // 20 출력

let b = 100;
if(true){
  //console.log(b); //error!! 호이스팅 안됨
  let a = 200;
  console.log(b); //200 출력
}
console.log(b); //100 출력
```

## Arrow Function(화살표 함수)
화살표 함수는 함수 표현식보다 단순하고 간결한 함수 작성 문법이다.

다음 세가지 표현은 같은 코드이다.
```javascript
function func(arg1, arg2, ...argN){
  return exp;
}//함수 선언문

let func = function(arg1, arg2, ...argN){
  return exp;
};//함수 표현식

let func = (arg1, arg2, ...argN) => exp;//화살표 함수
```

첫 번째 표현은 함수 선언문으로 전통적인 함수 작성방법이라고 할 수 있다. 두 번째 함수 표현식은 함수 호이스팅을 막고, 콜백으로 사용하기에 유용한 작성방법이다.

세 번째 표현이 화살표 함수로 함수 표현식을 단출 표현이라고 할 수 있다. 

### 화살표 함수 작성법
0. ``function`` 키워드를 사용하지 않고 ``=>``를 사용한다.


1. 매개 변수가 1개인 경우 ``()``를 생략할 수 있다.
```javascript
let func = (arg1) => { ... };
```
다음과 같이 작성한다.
```javascript
let func = arg1 => { ... };
```
매개 변수가 2개 이상인 경우에는 반드시 ``()``로 묶어야 한다.
```javascript
let func = (arg1, arg2) => { ... };
```
매개 변수가 없을 경우 ``()``만 작성한다.
```javascript
let func = () => { ... };
```


2. ``return``문만 있는 단일 표현식의 화살표 함수인 경우 ``{}``와 ``return`` 키워드를 생략한다.
```javascript
let func = arg1 => {
  return exp;
};
```
다음과 같이 작성할 수 있다.
```javascript
let func = arg1 => exp;
```


3. ``return``이 없는 단일 표현식의 화살표 함수일 경우 ``{}``를 생략하지 않는 것이 좋다.
```javascript
let v;
let func = arg1 => {
  v = arg1;
};
```
이 경우 ``{}``를 생략할 수 있으나, 생략 시 ``return`` 키워드를 생략한 건지, 원래 ``return`` 키워드를 안쓴건지 혼동될 수 있다.


4. 함수의 처리문이 단일 표현식이 아닌 경우는 ``{}``를 생략할 수 없다.
```javascript
let func = (arg1, arg2) => {
  let sum = arg1 + arg2;
  console.log('합계 : ", sum);
  return sum;
};
```

### Template Literals
Template Literals은 `` ` ``(백틱)을 사용하여 문자열 내에서 변수를 사용할 수 있도록 하는 방식이다.

특정 변수의 값을 넣는 형식 지정형 문자열을 작성할 때 유용하다.
```javascript
let num1 = 10;
let num2 = 5;
let result = num1 + num2;
let str = num1 + " + " + num2 + " = " + result;
```
위 예제의 마지막 문장을 Template Literal을 사용하여 다음과 같이 작성할 수 있다.
```javascript
...
let str = `${num1} + ${num2} = ${result}`;
```
위와 같이 직관적이며 간결하게 출력 형식 지정 및 변수의 값을 활용할 수 있다.

### export와 Import
프로그램의 규모가 커지면 여러 파일로 분할하여 코드를 작성하게되는데 이렇게 분할한 코드 파일을 모듈이라고 한다. 
모듈은 변수나 함수, 클래스가 될 수 있다. React를 비롯한 Js 프레임워크에서는 하나의 컴포넌트를 모듈단위로 작성하는 방식이 주로 쓰인다.

#### export(내보내기)
작성한 모듈을 다른 모듈에서 사용하도록 하기 위해서는 ``export``키워드를 사용하여 내보내기를 해야 한다.
```javascript
//변수 내보내기
export let sum = 0;

//함수 내보내기
export functoin func(){ exp; }
```

각각의 내보낼 코드에 따로 따로 export를 작성하지 않고 한꺼번에 처리할 수도 있다.
```javascript
let sum = 0;

functoin func(){ exp; }

export {sum, func};
```

``as`` 키워드를 사용하여 내보낼 변수나 함수, 클래스의 이름을 변경할 수 있다.
```javascript
let sum = 0;

functoin func(){ exp; }

export {sum as total, func as someFunc};
```
##### export default
일반적으로 모듈은 하나의 개체(변수, 함수, 클래스 등)로 작성하는 방식이 주로 사용된다.

``export default``는 개체가 하나면 선언되어 있는 모듈을 내보내기할 때 사용하는 키워드이다. 다음과 같이 사용한다.

```javascript
export default functoin func(){ exp; }
```
또는
```javascript
functoin func(){ exp; }

export default func;
``` 

``export``와 ``export default``의 차이는 내보내기할 개체가 하나일 때 ``export``는 모듈명을 ``{}``로 감싸야 하고, ``export default``는 감싸지 않는다는 것이다.

이것은 가져오기를 할 때도 동일하게 적용된다.


#### import(가져오기)
한 모듈에서 다른 모듈을 사용할 때 ``import`` 키워드를 사용하여 가져오기를 수행한다.

```javascript
import { total, someFunc } from `./SomeModule.js`;

total = 100;
someFunc();
```

한 모듈에서 2개 이상의 개체를 내보내기한 경우 위의 예제처럼 ``{}`` 안에 사용할 개체를 작성한다.

``export default``로 내보내기를 한 모듈의 경우 ``{}``를 작성하지 않는다.

```javascript
import func from './OtherModule.js`;

func();
```

### Destructing(구조분해할당)
Destructing은 배열이나 객체의 값을 꺼내 변수에 저장할 때 사용하는 매유 유용한 문법이다.

예를 들어 한 객체의 데이터를 꺼내서 변수에 저장하기 위한 이전 문법은 다음과 같다.
```javascript
const person = {
  name: '홍길동',
  age: 25,
  address: '어느시 무슨구'
};

//다른 코드들...

let name = person.name;
let age = person.age;
let address = person.address;

//다른 코드들...
```

위의 코드는 다음과 같이 처리할 수 있다.
```javascript
const person = {
  name: '홍길동',
  age: 25,
  address: '어느시 무슨구'
};

//다른 코드들...

let { name, age, address } = person;

//다른 코드들...
```
이와 같은 문법을 Destructing이라고 한다.

이 때 객체의 멤버변수와 그 값을 받는 변수의 이름은 동일해야 한다. 이름이 다를 경우 해당 변수는 ``undefined``가 된다.

다른 이름을 지정하고 싶을 경우 다음과 같이 작성한다.
```javascript
const person = {
  name: '홍길동',
  age: 25,
  address: '어느시 무슨구'
};

//다른 코드들...

let { name: firstName, age, address } = person;

console.log(firstName);//'홍길동' 출력
//다른 코드들...
```
``같은변수명`` ``: `` ``다른변수명`` 형식으로 작성하면 이후 사용 시 ``다른변수명``을 사용할 수 있다.

### Default parameters(기본 매개변수)
Default parameters는 매개변수에 기본값을 설정하는 문법이다.

Default parameters가 설정되지 않을 경우 해당 함수를 사용할 때 파라미터가 누락되면 ``undefined``가 처리된다.

```javascript
const newAge = age => age + 1;

newAge(); //age가 undefined 라서 NaN 출력
```

Default parameters를 설정하면 파라미터가 누락될 때 설정한 기본값을 사용하게 된다.

```javascript
const newAge = (age=20) => age + 1;

newAge(); //21 출력
```



